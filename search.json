[
  {
    "objectID": "s04_github_collaboration.html",
    "href": "s04_github_collaboration.html",
    "title": "Collaborating with Git and GitHub",
    "section": "",
    "text": "TipLearning Objectives\n\n\n\n\nApply the principles, features, and collaboration tools of Git and GitHub to effectively collaborate with colleagues on code\nAnalyze and evaluate common causes of conflicts that arise when collaborating on repositories\nDemonstrate the ability to resolve conflicts using Git conflict resolution techniques\nApply workflows and best practices that minimize conflicts on collaborative repositories",
    "crumbs": [
      "Git/GitHub",
      "Collaborating with Git and GitHub"
    ]
  },
  {
    "objectID": "s04_github_collaboration.html#introduction-to-git-and-github-tools-for-collaboration",
    "href": "s04_github_collaboration.html#introduction-to-git-and-github-tools-for-collaboration",
    "title": "Collaborating with Git and GitHub",
    "section": "1 Introduction to Git and GitHub Tools for Collaboration",
    "text": "1 Introduction to Git and GitHub Tools for Collaboration\n\n\n\nArtwork by Allison Horst\n\n\nGit is not only a powerful tool for individual work but also an excellent choice for collaborating with friends and colleagues. Git ensures that after you’ve completed your contributions to a repository, you can confidently synchronize your changes with changes made by others.\nOne of the easiest and most effective ways to collaborate using Git is by utilizing a shared repository on a hosting service like GitHub. This shared repository acts as a central hub, enabling collaborators to effortlessly exchange and merge their changes. With Git and a shared repository, you can collaborate seamlessly and work confidently, knowing that your changes will be integrated smoothly with those of your collaborators.\n\nThere are many advanced techniques for synchronizing Git repositories, but let’s start with a simple example.\nIn this example, the Collaborator will clone a copy of the Owner’s repository from GitHub, and the Owner will grant them Collaborator status, enabling the Collaborator to directly pull and push from the Owner’s GitHub repository.\n\n\n\n\n\nWe’ll be practicing the above workflow in the next exercises – here, a respository (aka repo) owner controls permissions on their remote repo, which is hosted on GitHub. They can push commits from their local repo to the remote repo. Similarly, they can pull commits from the remote repo to their cloned local repo(s) (remember, you can clone your repo to mulitple machines e.g. your laptop and your desktop). The repository owner adds a colleague as a collaborator by sending them an invite from the remote repo on GitHub. This collaborator can now push their own changes from their local repo to the now-shared remote repo (and also pull the Owner’s changes). Git and GitHub provide the tools for both colleagues to create and merge their changes to the shared remote repository.",
    "crumbs": [
      "Git/GitHub",
      "Collaborating with Git and GitHub"
    ]
  },
  {
    "objectID": "s04_github_collaboration.html#collaborating-with-a-trusted-colleague-without-conflicts",
    "href": "s04_github_collaboration.html#collaborating-with-a-trusted-colleague-without-conflicts",
    "title": "Collaborating with Git and GitHub",
    "section": "2 Collaborating with a trusted colleague without conflicts",
    "text": "2 Collaborating with a trusted colleague without conflicts\nWe start our collaboration by giving a trusted colleague access to our repository on GitHub. In this example, we define the Owner as the individual who owns the repository, and the Collaborator as the person whom the Owner chooses to give permission to make changes to their repository.\nThe Collaborator will make changes to the repository and then push those changes to the shared repository on GitHub. The Owner will then use pull to retrieve the changes without encountering any conflicts. This is the most ideal workflow.\nThe instructors will demonstrate this process in the next section.\n\nStep 1: Owner adds a Collaborator to their repository on GitHub\nThe Owner must change the settings of the remote repository and give the Collaborator access to the repository by inviting them as a collaborator. Once the Collaborator accepts the owner’s invitation, they will have push access to the repository – meaning they can contribute their own changes/commits to the Owner’s repository.\nTo do this, the owner will navigate to their remote repository on GitHub, then choose Settings &gt; Collaborators &gt; Add people, to send an email invitation. The invitation will show as “Pending” until accepted.\n\n\nStep 2: Collaborator clones the remote repository\nIn order to contribute, the Collaborator must clone the repository from the Owner’s GitHub account (Note: as a Collaborator, you won’t see the repository appear under your profile’s Repositories page). To do this, the Collaborator should navigate to the Owner’s repository on GitHub, then copy the clone URL. In RStudio, the Collaborator will create a new project from version control by pasting this clone URL into the appropriate dialog box (see the earlier chapter introducing GitHub).\n\n\nINTERMEDIATE STEP: Collaborator communicates with Owner that they plan to make some changes\nFrequent communication is SO important when collaborating! Letting one another know that you’re about to make and push changes to the remote repo can help to prevent merge conflicts (and reduce headaches). The easiest way to avoid merge conflicts is to ensure that you and your collaborators aren’t working on the same file(s)/section(s) of code at the same time.\n\n\nStep 3: Collaborator edits files locally\nWith the repo cloned locally, the Collaborator can now make changes to the README.md file, adding a line or statement somewhere noticeable near the top. Save the changes.\n\n\nStep 4: Collaborator commits, pulls, and pushs\nIt’s recommended that all collaborators (including the repo Owner) follow this workflow when syncing changes between their local repo and the remote repo (in this example, the Collaborator is now following these steps):\n\nadd and commit your modified file(s) (e.g. the updated README.md)\npull to fetch and merge changes from the remote/origin repository (in an ideal situation, as we’re demonstrating here, any potential changes are merged seamlessly without conflict)\npush your changes to the remote/origin repository\n\n\n\n\n\n\n\nNoteWhy do I need to add and commit files before pulling?\n\n\n\nRemember, git pull is a combination of git fetching remote changes to your local repo and git mergeing those changes from your local repo into your local working file(s).\nThe merge part of git pull will fail if you have uncommitted changes in your local working file(s) to avoid any potential overwriting of your own changes. Because of this, you should always, add/commit then pull, and finally push.\n\n\n\n\n\n\n\n\n\nINTERMEDIATE STEP: Collaborator communicates with Owner that they pushed their changes to GitHub\nRemember, communication is key! The Owner now knows that they can pull those changes down to their local repo.\n\n\nStep 5: Owner pulls new changes from the remote repo to their local repo\nThe Owner can now open their local working copy of the code in RStudio, and pull to fetch and merge those changes into their local copy.\nCongrats, the Owner now has your changes! Now, all three repositories – the remote/origin repository on GitHub, the Owner’s local repository, and the Collaborator’s local repository – should all be in the exact same state.\n\n\nINTERMEDIATE STEP: Owner communicates with Collaborator that they now plan to make some changes\nDid we mention that communication is important? :)\n\n\nStep 6: Owner edits, commits, pulls (just in case!) and pushes\nFollowing the same workflow as the Collaborator did earlier:\n\nadd and commit your modified file(s) (e.g. the updated README.md)\npull to fetch and merge changes from the remote/origin repository (in an ideal situation, as we’re demonstrating here, any potential changes are merged seamlessly without conflict)\npush your changes to the remote/origin repository\n\n\n\nINTERMEDIATE STEP: Owner communicates with Collaborator that they pushed their changes to GitHub\nYes, this seems silly to repeat, yet again – but it’s also easy to forget in practice!\n\n\nStep 7: Collaborator pulls new changes from the remote repo to their local repo\nThe Collaborator can now pull down those changes from the Owner, and all copies are once again fully synced. And just like that, you’ve successfully collaborated!",
    "crumbs": [
      "Git/GitHub",
      "Collaborating with Git and GitHub"
    ]
  },
  {
    "objectID": "s04_github_collaboration.html#ex1-no-conflict",
    "href": "s04_github_collaboration.html#ex1-no-conflict",
    "title": "Collaborating with Git and GitHub",
    "section": "3 Exercise 1: With a partner collaborate in a repository without a merge conflict",
    "text": "3 Exercise 1: With a partner collaborate in a repository without a merge conflict\n\n\n\n\n\n\nTipSetup\n\n\n\n\nGet into pairs, then choose one person as the Owner and one as the Collaborator\nBoth login to GitHub\n\nThese next steps are for the Owner:\n\nNavigate to the {FIRSTNAME}_test repository\nGo to Settings and navigate to Collaborators in the Access section on the left-hand side\nUnder Manage Access click the button Add people and type the username of your Collaborator in the search box\nOnce you’ve found the correct username, click Add {Collaborator username} to this repository\n\n\nNow, the Collaborator will follow this step:\n\nCheck your email for an invitation to GitHub or check your notifications (likely under Your Organizations) on GitHub to accept the invite to collaborate.\n\n\n\n\n3.1 Defining Merge Method\n\n\n\n\n\n\nCautionSome Git configuration to surpress warning messages\n\n\n\nGit version 2.27 includes a new feature that allows users to specify the default method for integrating changes from a remote repository into a local repository, without receiving a warning (this warning is informative, but can get annoying). To suppress this warning for this repository only we need to configure Git by running this line of code in the Terminal:\n\ngit config pull.rebase false\n\npull.rebase false is a default strategy for pulling where Git will first try to auto-merge the files. If auto-merging is not possible, it will indicate a merge conflict.\nNote: Unlike when we first configured Git, we do not include the --global flag here (e.g. git config --global pull.rebase false). This sets this default strategy for this repository only (rather than globally for all your repositories). We do this because your chosen/default method of grabbing changes from a remote repository (e.g. pulling vs. rebasing) may change depending on collaborator/workflow preference.\n\n\n\n\n\n\n\n\nNoteInstructions\n\n\n\nYou will do the exercise twice, where each person will get to practice being both the Owner and the Collaborator roles.\nRound One: Designate one person as the Owner and one as the Collaborator.\n\nStep 1: Owner adds Collaborator to {FIRSTNAME}_test repository (see Setup block above for detailed steps)\nStep 2: Collaborator clones the Owner’s {FIRSTNAME}_test repository\nStep 3: Collaborator edits the README file:\n\nCollaborator adds a new level 2 heading to README titled “Git Workflow”\n\nStep 4: Collaborator commits and pushes the README file with the new changes to GitHub\nStep 5: Owner pulls the changes that the Collaborator made\nStep 6: Owner edits the README file:\n\nUnder “Git Workflow”, Owner adds the steps of the Git workflow we’ve been practicing\n\nStep 7: Owner commits and pushes the README file with the new changes to GitHub\nStep 8: Collaborator pulls the Owners changes from GitHub\n\nRound Two: Switch roles - Collaborator becomes Owner and vise versa.\n\nStep 1: Owner adds Collaborator to {FIRSTNAME}_test repository\nStep 2: Collaborator clones the Owner’s {FIRSTNAME}_test repository\nStep 3: Collaborator edits the README file:\n\nCollaborator adds a new level 2 heading to README titled “How to Create a Git Repository from an existing project” and adds the high level steps for this workflow\n\nStep 4: Collaborator commits and pushes the README file with the new changes to GitHub\nStep 5: Owner pulls the changes that the Collaborator made\nStep 6: Owner edits the README file:\n\nUnder “How to Create a Git Repository”, Owner adds the high level steps for this workflow\n\nStep 7: Owner commits and pushes the README file with the new changes to GitHub\nStep 8: Collaborator pulls the Owners changes from GitHub\n\nHint: If you don’t remember how to create a Git repository, refer to the chapter Intro to Git and GitHub where we created two Git repositories",
    "crumbs": [
      "Git/GitHub",
      "Collaborating with Git and GitHub"
    ]
  },
  {
    "objectID": "s04_github_collaboration.html#a-note-on-advanced-collaboration-techniques",
    "href": "s04_github_collaboration.html#a-note-on-advanced-collaboration-techniques",
    "title": "Collaborating with Git and GitHub",
    "section": "4 A Note on Advanced Collaboration Techniques",
    "text": "4 A Note on Advanced Collaboration Techniques\nThere are many Git and GitHub collaboration techniques, some more advanced than others. We won’t be covering advanced strategies in this course. But here is a table for your reference on a few popular Git collaboration workflow strategies and tools.\n\n\n\n\n\n\n\n\n\nCollaboration Technique\nBenefits\nWhen to Use\nWhen Not to Use\n\n\n\n\nBranch Management Strategies\n1. Enables parallel development and experimentation2. Facilitates isolation of features or bug fixes3. Provides flexibility and control over project workflows\nWhen working on larger projects with multiple features or bug fixes simultaneously.When you want to maintain a stable main branch while developing new features or resolving issues on separate branches.When collaborating with teammates on different aspects of a project and later integrating their changes.\nWhen working on small projects with a single developer or limited codebase.When the project scope is simple and doesn’t require extensive branch management.When there is no need to isolate features or bug fixes.\n\n\nCode Review Practices\n1. Enhances code quality and correctness through feedback2. Promotes knowledge sharing and learning within the team3. Helps identify bugs, improve performance, and ensure adherence to coding standards\nWhen collaborating on a codebase with team members to ensure code quality and maintain best practices.When you want to receive feedback and suggestions on your code to improve its readability, efficiency, or functionality.When working on critical or complex code that requires an extra layer of scrutiny before merging it into the main branch.\nWhen working on personal projects or small codebases with no collaboration involved.When time constraints or project size make it impractical to conduct code reviews.When the codebase is less critical or has low complexity.\n\n\nForking\n1. Enables independent experimentation and development2. Provides a way to contribute to a project without direct access3. Allows for creating separate, standalone copies of a repository\nWhen you want to contribute to a project without having direct write access to the original repository.When you want to work on an independent variation or extension of an existing project.When experimenting with changes or modifications to a project while keeping the original repository intact.\nWhen collaborating on a project with direct write access to the original repository.When the project does not allow external contributions or forking.When the project size or complexity doesn’t justify the need for independent variations.\n\n\nPull Requests\n1. Facilitates code review and discussion2. Allows for collaboration and feedback from team members3. Enables better organization and tracking of proposed changes\nWhen working on a shared repository with a team and wanting to contribute changes in a controlled and collaborative manner.When you want to propose changes to a project managed by others and seek review and approval before merging them into the main codebase.\nWhen working on personal projects or individual coding tasks without the need for collaboration.When immediate changes or fixes are required without review processes.When working on projects with a small team or single developer with direct write access to the repository.\n\n\n\nThe “When Not to Use” column provides insights into situations where it may be less appropriate / unnecessary to use each collaboration technique, helping you make informed decisions based on the specific context and requirements of your project.\nThese techniques provide different benefits and are used in various collaboration scenarios, depending on the project’s needs and team dynamics.",
    "crumbs": [
      "Git/GitHub",
      "Collaborating with Git and GitHub"
    ]
  },
  {
    "objectID": "s04_github_collaboration.html#merge-conflicts",
    "href": "s04_github_collaboration.html#merge-conflicts",
    "title": "Collaborating with Git and GitHub",
    "section": "5 Merge conflicts",
    "text": "5 Merge conflicts\nMerge conflicts occur when both collaborators make conflicting changes to the same file. Resolving merge conflicts involves identifying the root of the problem and restoring the project to a normal state. Good communication, discussing file sections to work on, and avoiding overlaps can help prevent merge conflicts. However, if conflicts do arise, Git warns about potential issues and ensures that changes from different collaborators based on the same file version are not overwritten. To resolve conflicts, you need to explicitly specify whose changes should be used for each conflicting line in the file.\nIn this image, we see collaborators mbjones and metamattj have both made changes to the same line in the same README.md file. This is causing a merge conflict because Git doesn’t know whose changes came first. To resolve it, we need to tell Git whose changes to keep for that line, and whose changes to discard.\n\n\n5.1 Common ways to resolve a merge conflict\n1. Abort, abort, abort…\nSometimes you just made a mistake. When you get a merge conflict, the repository is placed in a “Merging” state until you resolve it. There’s a Terminal command to abort doing the merge altogether:\n\ngit merge --abort\n\nOf course, after doing that you still haven’t synced with your Collaborator’s changes, so things are still unresolved. But at least your repository is now usable on your local machine.\n2. Checkout\nThe simplest way to resolve a conflict, given that you know whose version of the file you want to keep, is to use the command line to tell Git to use either your changes (the person doing the merge), or their changes (the Collaborator).\n\nkeep your Collaborator’s file: git checkout --theirs conflicted_file.Rmd\nkeep your own file: git checkout --ours conflicted_file.Rmd\n\nOnce you have run that command, then run add (staging), commit, pull, and push the changes as normal.\n3. Pull and edit the file\nOption 2, above, requires the command line, however, we have a third option for resolving the merge conflict from RStudio. Using this approach will allow us to pick and choose some of our changes and some of our Collaborator’s changes by letting us manually edit and fix the conflicted file.\nWhen you pull a file with a conflict, Git will provide you with a warning modify the file so that it includes both your own changes and your Collaborator’s changes. The file will also appear in the Git tab with an orange U icon, which indicates that the file is Unmerged and therefore awaiting your help to resolve the conflict. It delimits these blocks of conflicted code with a series of less than and greater than signs, so they are easy to find:\n\n\n\n\n\nIn the above example, &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD marks the start of your changes. The ======= delimiter separates your changes from your Collaborator’s conflicting changes. &gt;&gt;&gt;&gt;&gt;&gt;&gt; mark the end of your Collaborator’s changes.\nTo resolve the conflicts, simply find all of these blocks, and edit them so that the file looks how you want (either pick your lines, your Collaborator’s lines, some combination, or something altogether new), and save. Be sure you removed the delimiter lines that started with\n\n&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n=======\n&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n\nOnce you have made those changes, you simply add (staging), commit, and push the files to resolve the conflict.",
    "crumbs": [
      "Git/GitHub",
      "Collaborating with Git and GitHub"
    ]
  },
  {
    "objectID": "s04_github_collaboration.html#producing-and-resolving-merge-conflicts",
    "href": "s04_github_collaboration.html#producing-and-resolving-merge-conflicts",
    "title": "Collaborating with Git and GitHub",
    "section": "6 Producing and resolving merge conflicts",
    "text": "6 Producing and resolving merge conflicts\nTo illustrate this process, the instructors are going to carefully create a merge conflict step-by-step, show how to resolve it, and show how to see the results of the successful merge after it is complete. First, the instructors will walk through the exercise to demonstrate the issues. Then, participants will pair up and try the exercise.\n\nStep 1: Owner and Collaborator ensure that their local repos are synced with the remote repo\nPair with the same partner as in Exercise 1 and decide who will be the Owner and who will be the Collaborator. Begin the exercise by ensuring that both the Owner and Collaborator have all of the changes synced from the remote repo to their local repos. This includes doing a git pull to ensure that you have all changes locally, and ensuring that the Git tab in RStudio doesn’t show any changes that need to be committed.\n\n\nStep 2: Owner makes a change and commits locally\nFrom this clean slate, the Owner will first modify and commit a small change. The Owner should add their name on a specific line of the README.md file (we will change the title in line 1). Save and commit the change (but DO NOT push). The Owner should now have a local but unpushed commit that the Collaborator does not yet have access to.\n\n\nStep 3: Collaborator makes a change and commits on the same line\nNow, the Collaborator will modify and commit a small change. The Collaborator should add their name to the same line of the README.md file (we will again change the title in line 1). Save and commit the change (but DO NOT push). The Collaborator should now also have a local but unpushed commit that the Owner does not yet have access to.\nAt this point, both the Owner and Collaborator have committed local changes, but neither have tried to share their changes via GitHub.\n\n\nStep 4: Collaborator pushes the file to GitHub\nSharing starts when the Collaborator pushes their changes to the GitHub repo, which updates GitHub with their version of the file. The Owner is now one revision behind, but doesn’t know it yet.\n\n\nStep 5: Owner pushes their changes and gets an error\nAt this point, the Owner tries to push their change to the repository, which triggers an error from GitHub. While the error message is long, it tells you everything needed (that the Owner’s repository doesn’t reflect the changes on GitHub, and that they need to pull before they can push).\n\n\n\nStep 6: Owner pulls from GitHub to get Collaborator changes\nFollowing the error message, the Owner pulls the changes from GitHub, and gets another, different error message. Here, it indicates that there is a merge conflict because of the conflicting lines.\n\nIn the Git pane of RStudio, the file is also flagged with an orange U, which stands for an unresolved merge conflict.\n\n\n\nStep 7: Owner edits the file to resolve the conflict\nTo resolve the conflict, the Owner now needs to edit the file. Again, as indicated above, Git has flagged the locations in the file where a conflict occurred with &lt;&lt;&lt;&lt;&lt;&lt;&lt;, =======, and &gt;&gt;&gt;&gt;&gt;&gt;&gt;. The Owner should edit the file, merging whatever changes are appropriate until the conflicting lines read how they should, and eliminate all of the marker lines with &lt;&lt;&lt;&lt;&lt;&lt;&lt;, =======, and &gt;&gt;&gt;&gt;&gt;&gt;&gt;.\n\nOf course, for scripts and programs, resolving the changes means more than just merging the text – whoever is doing the merging should make sure that the code runs properly and that none of the logic of the program has been broken.\n\n\n\nStep 8: Owner commits the resolved changes\nFrom this point forward, things proceed as normal. The Owner first adds the file, which changes the orange U to a blue M for modified. Then, the Owner commits the changes locally. The Owner now has a resolved version of the file on their system.\n\n\n\nStep 9: Owner pushes the resolved changes to GitHub\nThe Owner can now push the changes, without error, to GitHub.\n\n\n\nStep 10: Collaborator pulls the resolved changes from GitHub\nFinally, the Collaborator can pull from GitHub to get the changes (which include the resolved conflicted lines of code) that the Owner made.\n\n\nStep 11: Both can view commit history\nBoth the Collaborator and the Owner can view the history, which includes information about the conflict, the associated branch, and the merged changes.",
    "crumbs": [
      "Git/GitHub",
      "Collaborating with Git and GitHub"
    ]
  },
  {
    "objectID": "s04_github_collaboration.html#exercise-2-with-a-partner-collaborate-in-a-repository-and-resolve-a-merge-conflict",
    "href": "s04_github_collaboration.html#exercise-2-with-a-partner-collaborate-in-a-repository-and-resolve-a-merge-conflict",
    "title": "Collaborating with Git and GitHub",
    "section": "7 Exercise 2: With a partner collaborate in a repository and resolve a merge conflict",
    "text": "7 Exercise 2: With a partner collaborate in a repository and resolve a merge conflict\nNote you will only need to complete the Setup and Git configuration steps again if you are working in a new repository. Return to Exercise 1 for Setup and Git configuration steps.\n\n\n\n\n\n\nNoteInstructions\n\n\n\nNow it’s your turn. In pairs, intentionally create a merge conflict, and then go through the steps needed to resolve the issues and continue developing with the merged files. See the sections above for help with each of the steps below. You will do the exercise twice, where each person will get to practice being both the Owner and the Collaborator roles.\nRound One: Designate one person as the Owner and one as the Collaborator.\n\nStep 1: Both Owner and Collaborator pull to ensure both have the most up-to-date changes\nStep 2: Owner edits the README file and makes a change to the title and commits do not push\nStep 3: On the same line, Collaborator edits the README file and makes a change to the title and commits\nStep 4: Collaborator pushes the file to GitHub\nStep 5: Owner pushes their changes and gets an error\nStep 6: Owner pulls from GitHub to get Collaborator changes\nStep 7: Owner edits the README file to resolve the conflict\nStep 8: Owner commits the resolved changes\nStep 9: Owner pushes the resolved changes to GitHub\nStep 10: Collaborator pulls the resolved changes from GitHub\nStep 11: Both view commit history\n\nRound Two: Switch roles, )wner becomes Collaborator and vise versa\n\nStep 1: Both Owner and Collaborator pull to ensure both have the most up-to-date changes\nStep 2: Owner edits the README file and makes a change to line 2 and commits do not push\nStep 3: On the same line, Collaborator edits the README file and makes a change to line 2 and commits\nStep 4: Collaborator pushes the file to GitHub\nStep 5: Owner pushes their changes and gets an error\nStep 6: Owner pulls from GitHub to get Collaborator changes\nStep 7: Owner edits the README file to resolve the conflict\nStep 8: Owner commits the resolved changes\nStep 9: Owner pushes the resolved changes to GitHub\nStep 10: Collaborator pulls the resolved changes from GitHub\nStep 11: Both view commit history",
    "crumbs": [
      "Git/GitHub",
      "Collaborating with Git and GitHub"
    ]
  },
  {
    "objectID": "s04_github_collaboration.html#best-practices-to-avoid-merge-conflicts",
    "href": "s04_github_collaboration.html#best-practices-to-avoid-merge-conflicts",
    "title": "Collaborating with Git and GitHub",
    "section": "8 Best practices to avoid merge conflicts",
    "text": "8 Best practices to avoid merge conflicts\nSome basic rules of thumb can avoid the vast majority of merge conflicts, saving a lot of time and frustration. These are words our teams live by:\n\n\n\n\n\nXKCD 1597\n\n\n\nCommunicate often and set up effective communication channels\nTell each other what you are working on\nStart your working session with a pull\nPull immediately after you commit and before you push\nCommit often in small chunks (this helps you organize your work!)\nMake sure you and who you are collaborating with all fully understand the Git workflow you’re using (aka make sure you’re on the same page before you start)!\n\nA good workflow is encapsulated as follows:\nPull -&gt; Edit -&gt; Save -&gt; Add (stage) -&gt; Commit -&gt; Pull -&gt; (OPTIONAL) Fix any merge conflicts -&gt; Push\nIt may take a bit of practice to get comfortable with navigating merge conflicts, but like any other technical skill, they’ll become less intimidating with time. With careful communication and a consistent workflow, conflicts can be largely avoided or resolved when they do occur.",
    "crumbs": [
      "Git/GitHub",
      "Collaborating with Git and GitHub"
    ]
  },
  {
    "objectID": "s02_git_setup.html",
    "href": "s02_git_setup.html",
    "title": "Git and GitHub Setup",
    "section": "",
    "text": "TipLearning objectives\n\n\n\n\nSet global options in your .gitconfig file\nPractice how to set up GitHub Authentication using a Personal Access Token (PAT)",
    "crumbs": [
      "Setup",
      "Git and GitHub Setup"
    ]
  },
  {
    "objectID": "s02_git_setup.html#set-up-global-options-in-git",
    "href": "s02_git_setup.html#set-up-global-options-in-git",
    "title": "Git and GitHub Setup",
    "section": "1 Set up global options in Git",
    "text": "1 Set up global options in Git\nBefore using Git, you need to tell it who you are, also known as setting the global options. You can do this either on the terminal using git command or in the console using the R package usethis. For this lesson we will use the usethis package. However, you can also find the git commands to reference in the future.\n\n\n\n\n\n\nNoteWhat’s the Terminal?\n\n\n\nTechnically, the Terminal is an interface for the shell, a computer program. We can use the Terminal to directly tell a computer what to do. This is different from the Console in RStudio, which interprets R code and returns a value.\nYou can access the terminal through RStudio by clicking Tools &gt; Terminal &gt; New Terminal.\nA Terminal tab should now be open right next to the Console tab.\n\n\n\n\n\n\n\n\nTipDon’t be afraid to dip your toes in the Terminal\n\n\n\nMost of our Git operations will be done in RStudio, but there are some situations where you must work in the Terminal and use command line. It may be daunting to code in the Terminal, but as your comfort increases over time, you might find you prefer it. Either way, it’s beneficial to learn enough command line and to feel comfortable in the Terminal.\n\n\nTo introduce ourselves to git we are going to use the function usethis::use_git_config(), followed by usethis::git_default_branch_configure(). This will update our global options with our GitHub user name and email information.\nBelow you will find code to do this in the console using functions from the usethis package and the terminal using git commands.\n\nR ConsoleTerminal\n\n\nStep 1: set the user’s global user.name and user.email and define integrate changes from one branch into another branch for all repositories.\n\n1usethis::use_git_config(user.name = \"my_user_name\",\n2                        user.email = \"my_email@nceas.ucsb.edu\",\n3                        pull.rebase = \"false\")\n\n\n1\n\nAdd your personal name, e.g., “Casey O’Hara” - this is just to have a human-readable identifier for others see, not used for authentication or anything.\n\n2\n\nSet up your email address associated to your GitHub account. THIS is important - this is how GitHub links your changes to your user account.\n\n3\n\nSetting “merge” as the default strategy to integrate changes from one branch into another branch (for all repos). Check the note at the end of this chapter for more details.\n\n\n\n\nStep 2: define the name of the branch that gets created when you make the first commit in a new Git repo\n\nusethis::git_default_branch_configure(name = \"main\")\n\nStep 3: check to make sure everything looks correct\n\nusethis::git_sitrep()\n\n\n\nStep 1: set the user’s global user.name and user.email and define merge strategy for all repositories.\ngit config --global user.name \"my_user_name\"\nPress enter/return. The --global ensures this change is reflected in all repositories/projects. Your user name can be just your name, or your GitHub user name; just helps others identify you as the author of any changes you make.\nNote that if the code ran successfully, it will look like nothing happened. We will check at the end to make sure it worked.\nThen run:\ngit config --global user.email \"my_email@nceas.ucsb.edu\"\nPress enter/return. This one dees need to match the email associated with your GitHub account.\nThen run:\ngit config --global pull.rebase false\nStep 2: define the name of the branch that gets created when you make the first commit in a new Git repo.\ngit config --global init.defaultBranch main\nStep 3: check to make sure everything looks correct.\nThe following command return the global options you have set.\ngit config --global --list\n\n\n\n\n\n\n\n\n\n\nImportantuser.email matters!\n\n\n\nWhen you add your email to the global options you must use the exact same spelling that you used on GitHub - otherwise, Git won’t be able to sync to your account.\nYour user.name is just to make it easier for other humans to identify who is responsible for any Git-associated actions.\n\n\n\n\n\n\n\n\nNoteWhy set the default branch name to main?\n\n\n\nPreviously, the default branch name in Git was master, and while the origin of that term in the context of Git usage is blurry, it is probably related to a master/slave terminology used in old coding contexts. Because of this, a lot of coders and companies have moved away from that term as racially problematic, opting to set the default branch to main instead.\n\n\n\nSet a long timeout for the git cache\nFinally, we will run a step that is only necessary when working on a server. We need to set our credentials to not time out for a very long time. This is related to how our server operating system handles credentials - not doing this will make your Personal Access Token (PAT, which we will set up in the next section) expire after 15 min on the system, even though it is actually valid for at least a month. We will do this configuration in the terminal.\nYou can access the terminal through RStudio by clicking Tools &gt; Terminal &gt; New Terminal.\n\n\n\n\n\n\nWarningTHIS ONLY NEEDS TO BE RUN ON THE SERVER\n\n\n\nDO NOT RUN THE NEXT LINE when setting up Git and GitHub on your Personal Computer\n\n\nBy running the following command we are asking git to store our credential information in the cache for 10 million seconds (almost 4 months).\ngit config --global credential.helper 'cache --timeout=10000000'",
    "crumbs": [
      "Setup",
      "Git and GitHub Setup"
    ]
  },
  {
    "objectID": "s02_git_setup.html#github-authentication",
    "href": "s02_git_setup.html#github-authentication",
    "title": "Git and GitHub Setup",
    "section": "2 GitHub Authentication",
    "text": "2 GitHub Authentication\nGitHub generally requires Personal Access Tokens (PATs) instead of user passwords to authenticate communication between your computer and GitHub repositories.\nThe book Happy Git and GitHub for the useR has a wealth of information related to working with Git in R, and these instructions are based off of Chapter 9 Personal access token for HTTPS.\nWe will be using a Personal Access Token (PAT) in this course. For better security and long term use, we recommend taking the extra steps to set up SSH keys (check out Chapter 10 Set up Keys for SSH).\n\n\n\n\n\n\nTipSetting up your PAT\n\n\n\n\nRun usethis::create_github_token() in the Console.\nA new browser window should open up to GitHub, showing all the scopes options. You can review the scopes, but you don’t need to worry about which ones to select this time. The previous function automatically pre-selects some recommended scopes. Go ahead and scroll to the bottom and click “Generate Token”.\nCopy the generated token.\nBack in RStudio, run gitcreds::gitcreds_set() in the Console.\nPaste your PAT when the prompt asks for it.\nLast thing, run usethis::git_sitrep() in the Console to check your Git configuration and that you’ve successful stored your PAT. Note: look for Personal access token for 'https://github.com': '&lt;discovered&gt;'\n\nIf you see &lt;unset&gt; instead of &lt;discovered&gt; means your PAT is not correctly set. You need to troubleshoot.\n\n\nCongrats! Now you’ve setup your authentication you should be able to work with GitHub in RStudio now.",
    "crumbs": [
      "Setup",
      "Git and GitHub Setup"
    ]
  },
  {
    "objectID": "s02_git_setup.html#strategy-to-integrate-changes-from-one-branch-into-another",
    "href": "s02_git_setup.html#strategy-to-integrate-changes-from-one-branch-into-another",
    "title": "Git and GitHub Setup",
    "section": "3 Strategy to integrate changes from one branch into another",
    "text": "3 Strategy to integrate changes from one branch into another\nAbove we configured our global options for all the repositories you create in your server session to use pull.rebase = \"false\" as the strategy to integrate changes from two branches. With this we are saying to merge changes (as opposed to rebasing).\nIt is important to highlight that this configuration can be repo specific. This mean, you can configure how you want git to reconciling two branches at a repository level and not “for all repositories”. Allowing you to control on how git weaves things in when collaborating with others.\nIf you don’t define pull.rebase = \"false\" when setting the global configurations, you will have to define this for each repository you create. You will likely see the following message after you pull, meaning you have not define how to reconciling two branches in your repository.\n\nTo solve this issues you have to run either of the two suggested strategies on the terminal.\ngit config pull.rebase false\nor\ngit config pull.rebase true",
    "crumbs": [
      "Setup",
      "Git and GitHub Setup"
    ]
  },
  {
    "objectID": "s03_github_introduction.html",
    "href": "s03_github_introduction.html",
    "title": "Git and GitHub",
    "section": "",
    "text": "TipLearning Objectives\n\n\n\n\nApply the principles of Git to track and manage changes of a project\nUtilize the Git workflow including pulling changes, staging modified files, committing changes, pulling again to incorporate remote changes, and pushing changes to a remote repository\nCreate and configure Git repositories using different workflows",
    "crumbs": [
      "Git/GitHub",
      "Git and GitHub"
    ]
  },
  {
    "objectID": "s03_github_introduction.html#introduction-to-version-control",
    "href": "s03_github_introduction.html#introduction-to-version-control",
    "title": "Git and GitHub",
    "section": "1 Introduction to Version Control",
    "text": "1 Introduction to Version Control\n\n\n\n\n\nEvery file changes throughout the scientific process. Manuscripts are edited. Figures get revised. Code gets fixed when bugs are discovered. Sometimes those fixes lead to even more bugs, leading to more changes in the code base. Data files get combined. Those same files are split and combined again. In just one research project, we can expect thousands of changes!\nThese changes are important to track, and yet, we often use simplistic file names to do so. Many of us have experienced renaming a document or script multiple times with the disingenuous addition of “final” to the file name.\nA better way: version control\nVersion control provides an organized and transparent way to track changes in code and files. This practice was designed for software development, but is easily applicable to scientific programming.\nBenefits to using a version control software include:\n\nMaintain a history of project development while keeping your workspace clean\nFacilitate collaboration and transparency when working on teams\nExplore bugs or new features without disrupting your team’s work\nand more!\n\nThe version control system we’ll be diving into is Git, the most widely used modern version control system in the world.",
    "crumbs": [
      "Git/GitHub",
      "Git and GitHub"
    ]
  },
  {
    "objectID": "s03_github_introduction.html#introduction-to-git-github",
    "href": "s03_github_introduction.html#introduction-to-git-github",
    "title": "Git and GitHub",
    "section": "2 Introduction to Git + GitHub",
    "text": "2 Introduction to Git + GitHub\nLet’s start with a motivating example that’s representative of the types of problems Git can help us solve.\nFull Screen\n\n\nWith Git we can enhance our workflow:\n\nEliminate the need for cryptic filenames and comments to track our work.\nProvide detailed descriptions of our changes through commits, making it easier to understand the reasons behind code modifications.\nWork on multiple branches simultaneously, allowing for parallel development, and optionally merge them together.\nUse commits to access and even execute older versions of our code.\nAssign meaningful tags to specific versions of our code.\nMultiple individuals can work on the same analysis concurrently on their own computers, with the ability to merge everyone’s changes together.\n\n\n\n2.1 What exactly are Git and GitHub?\n\nGit: an open-source version control software\n\ndesigned to manage the versioning and tracking of files and project history\noperates locally on your computer, allowing you to create repositories and track changes\nprovides features such as committing changes, branching and merging code, reverting to previous versions, and managing project history\nworks directly with the files on your computer and does not require a network connection for most operations\nprimarily used through the command-line interface (CLI, e.g. Terminal), but also has various GUI tools available (e.g. RStudio IDE)\n\n\n\n\n\n\nGitHub: an online platform and service built around Git\n\nprovides a centralized hosting platform for Git repositories\nallows us to store, manage, and collaborate on Git repositories in the cloud\noffers additional features on top of Git, including a web-based interface, issue tracking, project management tools, pull requests, code review, and collaboration features\nenables easy sharing of code with others, facilitating collaboration and contribution to open source projects\nprovides a social aspect, allowing users to follow projects, star repositories, and discover new code\n\n\n\n\n\n\n\n2.2 How local files, Git, and GitHub work together\nIt can be daunting to understand the moving parts of the Git / GitHub life cycle (i.e. how file changes are tracked locally within repositories, then stored for safe-keeping and collaboration on remote repositories, then brought back down to a local machine(s) for continued development). It gets easier with practice, but here’s a high-level overview of how things work:\n\n2.2.1 What is the difference between a “normal” folder vs. a Git repository?\nLet’s pretend that we create a folder, called myFolder/, and add two files: myData.csv and myAnalysis.R. The contents of this folder are not currently version-controlled – meaning, for example, that if we make changes to myAnalysis.R that don’t work out, we have no way of accessing or reverting back to a previous version of myAnalysis.R (without remembering or rewriting things, of course).\nGit allows you to turn any “normal” folder, like myFolder/, into a Git repository – this is often referenced as “initializing a Git repository”. When you initialize a folder on your local computer as a Git repository, a hidden .git/ folder is created within that folder (e.g. myFolder/.git/). This .git/ folder is the Git repository.\nAs you use Git commands to capture versions or “snapshots” of your work, those versions (and their associated metadata) get stored within the .git/ folder. This allows you to access and/or recover any previous versions of your work. If you delete .git/, you delete your project’s history.\nHere is our example folder / Git repository represented visually:\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.2.2 How do I tell Git to preserve versions of my local working files?\nGit was built as a command-line tool, meaning we can use Git commands in the command line (e.g. Terminal, Git Bash, etc.) to take “snapshots” of our local working files. Alternatively, RStudio provides buttons that easily execute these Git commands.\nGenerally, that workflow looks something like this:\n\nMake changes to a file(s) (e.g. myAnalysis.R) in your working directory.\nStage the file(s) using git add myAnalysis.R (or git add . to stage multiple changed files at once). This lets Git know that you’d like to include the file(s) in your next commit.\nCommit the file(s) using git commit -m \"a message describing my changes\". This records those changes (along with a descriptive message) as a “snapshot” or version in the local repository (i.e. the .git/ folder).\n\n\n\n2.2.3 How do I send work from my local computer to GitHub?\nThe last step is synchronizing the changes made to our local repository with a remote repository (this remote repository is often stored on GitHub). The git push command is used to send local commits up to a remote repository. The git pull command is used to fetch changes from a remote repository and merge them into the local repository – pulling will become a regular part of your workflow when collaborating with others, or even when working alone but on different machines (e.g. a laptop at home and a desktop at the office).\nA basic git workflow represented as two islands, one with “local repo” and “working directory”, and another with “remote repo.” Bunnies move file boxes from the working directory to the staging area, then with Commit move them to the local repo. Bunnies in rowboats move changes from the local repo to the remote repo (labeled “PUSH”) and from the remote repo to the working directory (labeled “PULL”).\n\n\n\n\nArtwork by Allison Horst\n\n\n\n\n\n2.3 Let’s Look at a GitHub Repository\nThis screen shows the copy of a repository stored on GitHub, with its list of files, when the files and directories were last modified, and some information on who made the most recent changes.\n\n\n\nIf we drill into the “commits” for the repository, we can see the history of changes made to all of the files. Looks like kellijohnson was working on the project and fixing errors in December:\n\n\n\nAnd finally, if we drill into one of the changes made on December 20, we can see exactly what was changed in each file:\n\n\n\nTracking these changes, how they relate to released versions of software and files is exactly what Git and GitHub are good for. And we will show how they can really be effective for tracking versions of scientific code, figures, and manuscripts to accomplish a reproducible workflow.\n\n\n2.4 Git Vocabulary & Commands\nWe know the world of Git and GitHub can be daunting. Use these tables as references while you use Git and GitHub, and we encourage you to build upon this list as you become more comfortable with these tools.\nThis table contains essential terms and commands that complement intro to Git skills. They will get you far on personal and individual projects.\n\nEssential Git Commands\n\n\n\n\n\n\n\nTerm\nGit Command(s)\nDefinition\n\n\n\n\nAdd/Stage\ngit add [file]\nStaging marks a modified file in its current version to go into your next commit snapshot. You can also stage all modified files at the same time using git add .\n\n\nCommit\ngit commit\nRecords changes to the repository.\n\n\nCommit Message\ngit commit -m \"my commit message\"\nRecords changes to the repository and include a descriptive message (you should always include a commit message!).\n\n\nFetch\ngit fetch\nRetrieves changes from a remote repository but does not merge them into your local working file(s).\n\n\nPull\ngit pull\nRetrieves changes from a remote repository and merges them into your local working file(s).\n\n\nPush\ngit push\nSends local commits to a remote repository.\n\n\nStatus\ngit status\nShows the current status of the repository, including (un)staged files and branch information.\n\n\n\nThis table includes more advanced Git terms and commands that are commonly used in both individual and collaborative projects.\n\nAdvanced Git Commands\n\n\n\n\n\n\n\nTerm\nGit Command(s)\nDefinition\n\n\n\n\nBranch\ngit branch\nLists existing branches or creates a new branch.\n\n\nCheckout\ngit checkout [branch]\nSwitches to a different branch or restores files from a specific commit.\n\n\nClone\ngit clone [repository]\nCreates a local copy of a remote repository.\n\n\nDiff\ngit diff\nShows differences between files, commits, or branches.\n\n\nFork\n-\nCreates a personal copy of a repository under your GitHub account for independent development.\n\n\nLog\ngit log\nDisplays the commit history of the repository.\n\n\nMerge\ngit merge [branch]\nIntegrates changes from one branch into another branch.\n\n\nMerge Conflict\n-\nOccurs when Git cannot automatically merge changes from different branches, requiring manual resolution.\n\n\nPull Request (PR)\n-\nA request to merge changes from a branch into another branch, typically in a collaborative project.\n\n\nRebase\ngit rebase\nIntegrates changes from one branch onto another by modifying commit history.\n\n\nRemote\ngit remote\nManages remote repositories linked to the local repository.\n\n\nRepository\ngit init\nA directory where Git tracks and manages files and their versions.\n\n\nStash\ngit stash\nTemporarily saves changes that are not ready to be committed.\n\n\nTag\ngit tag\nAssigns a label or tag to a specific commit.\n\n\n\nGit has a rich set of commands and features, and there are many more terms beyond either table. Learn more by visiting the git documentation.",
    "crumbs": [
      "Git/GitHub",
      "Git and GitHub"
    ]
  },
  {
    "objectID": "s03_github_introduction.html#exercise-1-create-a-remote-repository-on-github",
    "href": "s03_github_introduction.html#exercise-1-create-a-remote-repository-on-github",
    "title": "Git and GitHub",
    "section": "3 Exercise 1: Create a remote repository on GitHub",
    "text": "3 Exercise 1: Create a remote repository on GitHub\n\n\n\n\n\n\nTipSetup\n\n\n\n\nLogin to GitHub\nClick the New repository button\nName it {FIRSTNAME}_test\nAdd a short description\nCheck the box to add a README.md file\nAdd a .gitignore file using the R template\nSet the LICENSE to Apache 2.0\n\n\n\nIf you were successful, it should look something like this:\n\n\n\n\n\nYou’ve now created your first repository! It has a couple of files that GitHub created for you: README.md, LICENSE, and .gitignore.\n\n\n\n\n\n\nNoteREADME.md files are used to share important information about your repository\n\n\n\nYou should always add a README.md to the root directory of your repository – it is a markdown file that is rendered as HTML and displayed on the landing page of your repository. This is a common place to include any pertinent information about what your repository contains, how to use it, etc.\n\n\n\n\n \n\nFor simple changes to text files, such as the README.md, you can make edits directly in the GitHub web interface.\n\n\n\n\n\n\nNoteChallenge\n\n\n\nNavigate to the README.md file in the file listing, and edit it by clicking on the pencil icon (top right of file). This is a regular Markdown file, so you can add markdown text. Add a new level-2 header called “Purpose” and add some bullet points describing the purpose of the repo. When done, add a commit message, and hit the Commit changes button.\n\n\n\n\n\n\n\nCongratulations, you’ve now authored your first versioned commit! If you navigate back to the GitHub page for the repository, you’ll see your commit listed there, as well as the rendered README.md file.\n\n\n\n\n\nThe GitHub repository landing page provides us with lots of useful information. To start, we see:\n\nall of the files in the remote repository\nwhen each file was last edited\nthe commit message that was included with each file’s most recent commit (which is why it’s important to write good, descriptive commit messages!)\n\nAdditionally, the header above the file listing shows the most recent commit, along with its commit message, and a unique ID (assigned by Git) called a SHA. The SHA (aka hash) identifies the specific changes made, when they were made, and by who. If you click on the SHA, it will display the set of changes made in that particular commit.\n\n\n\n\n\n\nCautionWhat should I write in my commit message?\n\n\n\nWriting effective Git commit messages is essential for creating a meaningful and helpful version history in your repository. It is crucial to avoid skipping commit messages or resorting to generic phrases like “Updates.” When it comes to following best practices, there are several guidelines to enhance the readability and maintainability of the codebase.\nHere are some guidelines for writing effective Git commit messages:\n\nBe descriptive and concise: Provide a clear and concise summary of the changes made in the commit. Aim to convey the purpose and impact of the commit in a few words.\nUse imperative tense: Write commit messages in the imperative tense, as if giving a command. For example, use “Add feature” instead of “Added feature” or “Adding feature.” This convention aligns with other Git commands and makes the messages more actionable.\nSeparate subject and body: Start with a subject line, followed by a blank line, and then provide a more detailed explanation in the body if necessary. The subject line should be a short, one-line summary, while the body can provide additional context, motivation, or details about the changes.\nLimit the subject line length: Keep the subject line within 50 characters or less. This ensures that the commit messages are easily scannable and fit well in tools like Git logs.\nCapitalize and punctuate properly: Begin the subject line with a capital letter and use proper punctuation. This adds clarity and consistency to the commit messages.\nFocus on the “what” and “why”: Explain what changes were made and why they were made. Understanding the motivation behind a commit helps future researchers and collaborators (including you!) comprehend its purpose.\nUse present tense for subject, past tense for body: Write the subject line in present tense as it represents the current state of the codebase. Use past tense in the body to describe what has been done.\nReference relevant issues: If the commit is related to a specific issue or task, include a reference to it. For example, you can mention the issue number or use keywords like “Fixes,” “Closes,” or “Resolves” followed by the issue number.",
    "crumbs": [
      "Git/GitHub",
      "Git and GitHub"
    ]
  },
  {
    "objectID": "s03_github_introduction.html#exercise-2-clone-your-repository-and-use-git-locally-in-rstudio",
    "href": "s03_github_introduction.html#exercise-2-clone-your-repository-and-use-git-locally-in-rstudio",
    "title": "Git and GitHub",
    "section": "4 Exercise 2: clone your repository and use Git locally in RStudio",
    "text": "4 Exercise 2: clone your repository and use Git locally in RStudio\nCurrently, our repository just exists on GitHub as a remote repository. It’s easy enough to make changes to things like our README.md file (as demonstrated above), from the web browser, but that becomes a lot harder (and discouraged) for scripts and other code files. In this exercise, we’ll bring a copy of this remote repository down to our local computer (aka clone this repository) so that we can work comfortably in RStudio.\n\n\n\n\n\n\nImportantAn important distinction\n\n\n\nWe refer to the remote copy of the repository that is on GitHub as the origin repository (the one that we cloned from), and the copy on our local computer as the local repository.\n\n\nStart by clicking the green Code button (top right of your file listing) and copying the URL to your clipboard (this URL represents the repository location):\n\n\n\n\n\n\n\nRStudio makes working with Git and version controlled files easy – to do so, you’ll need to be working within an R project folder. The following steps will look similar to those you followed when first creating an R Project, with a slight difference. Follow the instructions in the Setup box below to clone your remote repository to your local computer in RStudio:\n\n\n\n\n\n\nTipSetup\n\n\n\n\nClick File &gt; New Project\nSelect Version Control and paste the remote repository URL (which should be copied to your clipboard) in the Repository URL field\nPress Tab, which will auto-fill the Project directory name field with the same name as that of your remote repo – while you can name the local copy of the repository anything, it’s typical (and highly recommended) to use the same name as the GitHub repository to maintain the correspondence\n\n\n\n\n\n\n\n\n\nOnce you click Create Project, a new RStudio window will open with all of the files from the remote repository copied locally. Depending on how your version of RStudio is configured, the location and size of the panes may differ, but they should all be present – you should see a Git tab, as well as the Files tab, where you can view all of the files copied from the remote repo to this local repo.\n\n\n\n\nYou’ll note that there is one new file sam_test.Rproj, and three files that we created earlier on GitHub (.gitignore, LICENSE, and README.md).\nIn the Git tab, you’ll note that the one new file, sam_test.Rproj, is listed. This Git tab is the status pane that shows the current modification status of all of the files in the repository. Here, we see sam_test.Rproj is preceded by a ?? symbol to indicate that the file is currently untracked by Git. This means that we have not yet committed this file using Git (i.e. Git knows nothing about the file; hang tight, we’ll commit this file soon so that it’s tracked by Git). As you make version control decisions in RStudio, these icons will change to reflect the current version status of each of the files.\nInspect the history. Click on the History button in the Git tab to show the log of changes that have occurred – these changes will be identical to what we viewed on GitHub. By clicking on each row of the history, you can see exactly what was added and changed in each of the two commits in this repository.\n\n\n\n\n\n\n\n\nNoteChallenge\n\n\n\n\nMake a change to the README.md file – this time from RStudio – then commit the README.md change\nAdd a new section to your README.md called “Creator” using a level-2 header. Under it include some information about yourself. Bonus: Add some contact information and link your email using Markdown syntax.\n\n\n\nOnce you save, you’ll immediately see the README.md file show up in the Git tab, marked as a modification. Select the file in the Git tab, and click Diff to see the changes that you saved (but which are not yet committed to your local repository). Newly made changes are highlighted in green.\n\n\n\n\nCommit the changes. To commit the changes you made to the README.md file using RStudio’s GUI (Graphical User Interface), rather than the command line:\n\nStage (aka add) README.md by clicking the check box next to the file name – this tells Git which changes you want included in the commit and is analogous to using the git command, git add README.md, in the command line\nCommit README.md by clicking the Commit button and providing a descriptive commit message in the dialog box. Press the Commit button once you’re satisfied with your message. This is analogous to using the git command, git commit -m \"my commit message\", in the command line.\n\n\nA few notes about our local repository’s state:\n\nWe still have a file, sam_test.Rproj, that is listed as untracked (denoted by ?? in the Git tab).\nYou should see a message at the top of the Git tab that says, Your branch is ahead of ‘origin/main’ by 1 commit., which tells us that we have 1 commit in the local repository, but that commit has not yet been pushed up to the origin repository (aka remote repository on GitHub).\n\nCommit the remaining project file by staging/adding and committing it with an informative commit message.\n\nWhen finished, you’ll see that no changes remain in the Git tab, and the repository is clean.\nInspect the history. Note that under Changes, the message now says:\nYour branch is ahead of ‘origin/main’ by 2 commits.\nThese are the two commits that we just made, but have not yet been pushed to GitHub.\nClick on the History button to see a total of four commits in the local repository (the two we made directly to GitHub via the web browser and the two we made in RStudio).\nPush these changes to GitHub. Now that we’ve made and committed changes locally, we can push those changes to GitHub using the Push button. This sends your changes to the remote repository (on GitHub) leaving your repository in a totally clean and synchronized state (meaning your local repository and remote repository should look the same).\n\n\n\n\n\n\nNoteIf you are prompted to provide your GitHub username and password when Pushing…\n\n\n\nit’s a good indicator that you did not set your GitHub Personal Access Token (PAT) correctly. You can redo the steps outlined in the GitHub Authentication section to (re)set your PAT, then Push again.\n\n\n\n &lt;––&gt;\n\nIf you look at the History pane again, you’ll notice that the labels next to the most recent commit indicate that both the local repository (HEAD) and the remote repository (origin/HEAD) are pointing at the same version in the history. If we look at the commit history on GitHub, all the commits will be shown there as well.\n\n\n\n4.1 Defining Merge Method\n\n\n\n\n\n\nCautionSome Git configuration to surpress warning messages\n\n\n\nGit version 2.27 includes a new feature that allows users to specify the default method for integrating changes from a remote repository into a local repository, without receiving a warning (this warning is informative, but can get annoying). To suppress this warning for this repository only we need to configure Git by running this line of code in the Terminal:\n\ngit config pull.rebase false\n\npull.rebase false is a default strategy for pulling where Git will first try to auto-merge the files. If auto-merging is not possible, it will indicate a merge conflict (more on resolving merge conflicts in Collaborating with Git and GitHub).\nNote: Unlike when we first configured Git, we do not include the --global flag here (e.g. git config --global pull.rebase false). This sets this default strategy for this repository only (rather than globally for all your repositories). We do this because your chosen/default method of grabbing changes from a remote repository (e.g. pulling vs. rebasing) may change depending on collaborator/workflow preference.",
    "crumbs": [
      "Git/GitHub",
      "Git and GitHub"
    ]
  },
  {
    "objectID": "s03_github_introduction.html#exercise-3-setting-up-git-on-an-existing-project",
    "href": "s03_github_introduction.html#exercise-3-setting-up-git-on-an-existing-project",
    "title": "Git and GitHub",
    "section": "5 Exercise 3: Setting up Git on an existing project",
    "text": "5 Exercise 3: Setting up Git on an existing project\nThere are a number of different workflows for creating version-controlled repositories that are stored on GitHub. We started with Exercise 1 and Exercise 2 using one common approach: creating a remote repository on GitHub first, then cloning that repository to your local computer (you used your {FIRSTNAME}_test repo).\nHowever, you may find yourself in the situation where you have an existing directory (i.e. a “normal” folder) of code that you want to make a Git repository out of, and then send it to GitHub. In this last exercise, we will practice this workflow using your training_{USERNAME} project.\nFirst, switch to your training_{USERNAME} project using the RStudio project dropdown menu. The project drop down menu is in the upper right corner of your RStudio pane. Click the drop down next to your project name ({FIRSTNAME}_test), and then select the training_{USERNAME} project from the RECENT PROJECTS list.\nThere are a few approaches for turning an existing project folder into a Git repository, then sending it to GitHub – if you’re an R-user, the simplest way is to use the {usethis} package, which is built to automate tasks involved with project setup and development. However, you can also initialize a local git repository and set the remote repository from the command line (a language-agnostic workflow). Steps for both approaches are included below (demonstrated using your training_{USERNAME} project):\n\nUsing R & {usethis}Using the command line\n\n\n\nInstall the {usethis} package (if you haven’t done so already) by running the following in your Console:\n\n\ninstall.packages(\"usethis\")\n\n\nInitialize training_{USERNAME} as a Git repository by running usethis::use_git() in the Console. Choose yes when asked if it’s okay to commit any uncommitted files. Choose yes again if asked to restart R. Once complete, you should see the Git tab appear in your top left pane in RStudio and a .gitignore file appear in your Files tab.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote.gitignore files allow you to specify which files/folders you don’t want Git to track\n\n\n\nA .gitignore file is automatically created in the root directory of your project when you initialize it as a Git repository. You’ll notice that there are already some R / R Project-specific files that have been added by default.\nWhy is this useful? For many reasons, but possibly the greatest use-case is adding large files (GitHub has a file size limit of 2 GB) or files with sensitive information (e.g. keys, tokens) that you don’t want to accidentally push to GitHub.\nHow do I do this? Let’s say I create a file with sensitive information that I don’t want to push to GitHub. I can add a line to my .gitignore file:\n\n# added by default when I initalized my RProj as a Git Repository\n.Rproj.user\n.Rhistory\n.Rdata\n.httr-oauth\n.DS_Store\n.quarto\n\n# add file so that it doesn't get pushed to the remote repo (on GitHub); \ncontains_sensitive_info.R\n\nIf this file is currently untracked by Git, it should appear in my Git tab. Once I add it to the .gitignore and save the modified .gitignore file, you should see contains_sensitive_info.R disappear from the Git tab, and a modified .gitignore (denoted by a blue M) appear. Stage/commit/push this modified .gitignore file.\n\n\n\nCreate an upstream remote repository on GitHub by running usethis::use_github() in the Console. Your web browser should open up to your new GitHub repository, with the same name as your local Git repo/R Project.\n\n\n\n\n\n\n\n\n\n\n\nEnsure that your default branch is named main rather than master by:\n\nrunning git branch in the Terminal to list all your branches (you should currently only have one, which is your default)\nif it’s named master, run the following line in the Console to update it\n\n\n\nusethis::git_default_branch_rename(from = \"master\", to = \"main\")\n\nYou can verify that your update worked by running git branch once more in the Terminal.\n\n\n\n\n\n\nNoteWhy are we doing this?\n\n\n\nThe racist “master” terminology for git branches motivates us to update our default branch to “main” instead.\nThere is a push across platforms and software to update this historical default branch name from master to main. GitHub has already done so – you may have noticed that creating a remote repository first (like we did in Exercises 1 & 2) results in a default branch named main. Depending on your version of Git, however, you may need to set update the name manually when creating a local git repository first (as we’re doing here).\n\n\n\nYou’re now ready to edit, stage/add, commit, and push files to GitHub as practiced earlier!\n\n\n\n\n\n\n\nCautionChallenge: add a README.md file to training_{USERNAME}\n\n\n\nGitHub provides a button on your repo’s landing page for quickly adding a README.md file. Click the Add a README button and use markdown syntax to create a README.md. Commit the changes to your repository.\nGo to your local repository (in RStudio) and pull the changes you made.\n\n\n\n\nWhile we’ll be using the RStudio Terminal here, you can use any command-line interface (e.g. Mac Terminal, Git Bash, etc.) that allows for git interactions (if you plan to use a command-line interface that is not the RStudio Terminal, make sure to navigate to your project directory (e.g. using cd file/path/to/project/directory) before initializing your repository.\n\nInitialize training_{USERNAME} as a Git repository by running git init in the Terminal. You should get a message that says something like:\n\n\nInitialized empty Git repository in /home/username/training_username/.git/\n\n\n\n\n\n\n\nImportantYou may have to quit and reopen your RStudio session on the server for the Git tab to appear\n\n\n\nYou’ll likely need to help included-crab along in recognizing that this R Project has been initialized as a git repository – click Session &gt; Quit Session… &gt; New Session &gt; choose training_{USERNAME} to reopen your project.\n\n\nOnce complete, you should see the Git tab appear in your top left pane in RStudio and a .gitignore file appear in your Files tab.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote.gitignore files allow you to specify which files/folders you don’t want Git to track\n\n\n\nA .gitignore file is automatically created in the root directory of your project when you initialize it as a Git repository. You’ll notice that there are already some R / R Project-specific files that have been added by default.\nWhy is this useful? For many reasons, but possibly the greatest use-case is adding large files (GitHub has a file size limit of 2 GB) or files with sensitive information (e.g. keys, tokens) that you don’t want to accidentally push to GitHub.\nHow do I do this? Let’s say I create a file with sensitive information that I don’t want to push to GitHub. I can add a line to my .gitignore file:\n\n# added by default when I initalized my RProj as a Git Repository\n.Rproj.user\n.Rhistory\n.Rdata\n.httr-oauth\n.DS_Store\n.quarto\n\n# add file so that it doesn't get pushed to the remote repo (on GitHub); \ncontains_sensitive_info.R\n\nIf this file is currently untracked by Git, it should appear in my Git tab. Once I add it to the .gitignore and save the modified .gitignore file, you should see contains_sensitive_info.R disappear from the Git tab, and a modified .gitignore (denoted by a blue M) appear. Stage/commit/push this modified .gitignore file.\n\n\n\nEnsure that your default branch is named main rather than master by:\n\nrunning git branch in the Terminal to list all your branches (you should currently only have one, which is your default)\nif it’s named master, run the following line in the Terminal to update it\n\n\n\n# for Git version 2.28+ (check by running `git --version`)\n# this sets the default branch name to `main` for any new repos moving forward\ngit config --global init.defaultBranch main\n\n# for older versions of Git\n# this sets the default branch name to `main` ONLY for this repo \ngit branch -m master main\n\nYou can verify that your update worked by running git branch once more in the Terminal.\n\n\n\n\n\n\nNoteWhy are we doing this?\n\n\n\nThe racist “master” terminology for git branches motivates us to update our default branch to “main” instead.\nThere is a push across platforms and software to update this historical default branch name from master to main. GitHub has already done so – you may have noticed that creating a remote repository first (like we did in Exercises 1 & 2) results in a default branch named main. Depending on your version of Git, however, you may need to set update the name manually when creating a local git repository first (as we’re doing here).\n\n\n\nStage/Add your files. It’s helpful to first run git status to check the state of your local repository (particularly if you aren’t using RStudio / have access to a GUI with a Git tab-esque feature) – this will tell you which files have been modified or are untracked and that are currently unstaged (in red). What appears here should look just like what appears in the Git tab:\n\n\n\n\n\n\n\n\n\n\nRun git add . in the Terminal to stage all files at once (or git add {FILENAME} to stage individual files). Running git status again will show you which files have been staged (in green). You may have to refresh your Git tab to see the change in state reflected in the GUI.\n\n\n\n\n\n\n\n\n\n\nCommit your files by running git commit -m \"an informative commit message\" in the Terminal. Refreshing your Git tab will cause them to disappear (just as they do when you commit using RStudio’s GUI buttons). You can run git log in the Terminal to see a history of your past commits (currently, we only have this one).\n\n\n\n\n\n\n\n\n\n\n\nCreate an empty remote repository by logging into GitHub and creating a new repository, following the same steps as in Exercise 1. IMPORTANTLY, DO NOT initialize your remote repo with a README license, or .gitignore file – doing so now can lead to merge conflicts. We can add them after our local and remote repos are linked. Name your remote repository the same as your local repository (i.e. training_{USERNAME}).\nLink your remote (GitHub) repository to your local Git repository. Your empty GitHub repo conveniently includes instructions for doing so. Copy the code under push an existing repository from the command line to your clipboard, paste into your RStudio Terminal, and press return/enter.\n\n\n\n\n\n\n\n\n\n\nThese commands do three things:\n\nAdds the GitHub repository as the remote repository (i.e. links your local repo to the remote repo)\nRenames the default branch to main\nPushes the main branch to the remote GitHub repository\n\nHead back to your browser and refresh your GitHub repository page to see your files appear!\n\nYou’re now ready to edit, stage/add, commit, and push files to GitHub as practiced earlier!\n\n\n\n\n\n\n\nCautionChallenge: add a README.md file to training_{USERNAME}\n\n\n\nGitHub provides a button on your repo’s landing page for quickly adding a README.md file. Click the Add a README button and use markdown syntax to create a README.md. Commit the changes to your repository.\nGo to your local repository (in RStudio) and pull the changes you made.",
    "crumbs": [
      "Git/GitHub",
      "Git and GitHub"
    ]
  },
  {
    "objectID": "s03_github_introduction.html#go-further-with-git",
    "href": "s03_github_introduction.html#go-further-with-git",
    "title": "Git and GitHub",
    "section": "6 Go further with Git",
    "text": "6 Go further with Git\nThere’s a lot we haven’t covered in this brief tutorial. There are some great and much longer tutorials that cover advanced topics, such as:\n\nUsing Git on the command line\nResolving conflicts\nBranching and merging\nPull requests versus direct contributions for collaboration\nUsing .gitignore to protect sensitive data\nGitHub Issues - how to use them for project management and collaboration\n\nand much, much more.",
    "crumbs": [
      "Git/GitHub",
      "Git and GitHub"
    ]
  },
  {
    "objectID": "s03_github_introduction.html#git-resources",
    "href": "s03_github_introduction.html#git-resources",
    "title": "Git and GitHub",
    "section": "7 Git resources",
    "text": "7 Git resources\n\nPro Git Book\nHappy Git and GitHub for the useR\nGitHub Documentation\nLearn Git Branching is an interactive tool to learn Git on the command line\nSoftware Carpentry Version Control with Git\nBitbucket’s tutorials on Git Workflows",
    "crumbs": [
      "Git/GitHub",
      "Git and GitHub"
    ]
  },
  {
    "objectID": "s06_github_publishing.html",
    "href": "s06_github_publishing.html",
    "title": "Publishing to the Web",
    "section": "",
    "text": "TipLearning Objectives\n\n\n\n\nHow to use Git, GitHub (+Pages), and Quarto to publish an analysis to the web"
  },
  {
    "objectID": "s06_github_publishing.html#introduction",
    "href": "s06_github_publishing.html#introduction",
    "title": "Publishing to the Web",
    "section": "1 Introduction",
    "text": "1 Introduction\nSharing your work with others in engaging ways is an important part of the scientific process.\nSo far in this course, we’ve introduced a small set of powerful tools for doing open science:\n\nR and its many packages\nRStudio\nGit\nGitHub\nQuarto\n\nQuarto, in particular, is amazingly powerful for creating scientific reports but, so far, we haven’t tapped its full potential for sharing our work with others.\nIn this lesson, we’re going to take our training_{USERNAME} GitHub repository and turn it into a beautiful and easy to read web page using the tools listed above.\n\n\n\n\n\n\nNoteSet up\n\n\n\n\nMake sure you are in training_{USERNAME} project\nAdd a new Quarto file at the top level called index.qmd\n\nGo to the RStudio menu File -&gt; New File -&gt; Quarto Document\nThis will bring up a dialog box. Add the title “GitHub Pages Example”, keep the Default Output Format as “HTML”, and then click “OK”\n\nSave the Quarto Document you just created. Use index.qmd as the file name\n\nBe sure to use the exact case (lower case “index”) as different operating systems handle case differently and it can interfere with loading your web page later\n\nPress “Render” and observe the rendered output\n\nNotice the new file in the same directory index.html\nThis is our Quarto file rendered as HTML (a web page)\n\nCommit your changes (for both index.qmd and index.html) with a commit message, and push to GitHub\n\nIf you have a folder called index_files, commit this as well. This folder contains the all the formatting and display settings for your html page.\n\nOpen your web browser to the github.com and navigate to the page for your training_{USERNAME} repository\nActivate GitHub Pages for the main branch\n\nGo to Settings -&gt; Pages (underneath the Code and Automation section)\nKeep the “Source” as “Deploy from a branch”\nUnder “Branch” you’ll see a message that says “GitHub Pages is currently disabled”. To change this, change the branch from “None” to main. Keep the folder as the root and then click “Save”\nYou should see the message change to “Your GitHub Pages site is currently being built from the main branch”\n\n\nNote: index.qmd represents the default file for a web site, and is returned whenever you visit the web site but doesn’t specify an explicit file to be returned.\n\n\nNow, the rendered website version of your repo will show up at a special URL.\nGitHub Pages follows a convention like this:\n\nNote that it changes from github.com to github.io\n\nGo to https://{username}.github.io/{repo_name}/ (Note the trailing /)\nObserve the awesome rendered output\n\nNow that we’ve successfully published a web page from an Quarto Document, let’s make a change to our Quarto Document and follow the steps to publish the change on the web:\n\n\n\n\n\n\nNoteUpdate content in your published page\n\n\n\n\nGo back to your index.qmd\nDelete all the content, except the YAML frontmatter\nType “Hello world”\nRender index.qmd\nUse Git workflow: Stage (add) -&gt; Commit -&gt; Pull -&gt; Push\nGo back to https://{username}.github.io/{repo_name}/\n\n\n\nNext, we will show how you can link different qmd’s rendered into html so you can easily share different parts of your work.\n\n\n\n\n\n\nExerciseExercise 1\n\n\n\n\n\n\nIn this exercise, you’ll create a table of contents with the lessons of this course on the main page, and link some of the files we have work on so far.\n\nGo back to the RStudio server and to your index.qmd file\nCreate a table of contents with the names of the main technical lessons of this course, like so:\n\n## Course Lessons\n\n- Introduction to Literate Analysis Using Quarto \n- Cleaning and Wrangling data\n- Data Visualization\n- Functions and packages\n\n## Course Practice Session\n\n- Practice I\n- Practice II\n- Practice III\n\n\nMake sure you have the html versions of your intro-to-qmd.qmd and data-cleaning.qmd files. If you only see the qmd version, you need to “Render” your files first\nIn your index.qmd let’s add the links to the html files we want to show on our webpage. Do you remember the Markdown syntax to create a link?\n\n\n\nMarkdown syntax to create a link:\n\n\n[Text you want to hyperlink](link)\n\nExample: [Data wrangling and cleaning](scripts/data-wrangling-cleaning.html)\n\n\n\n\nRender index.qmd\nUse Git workflow: Stage (add) -&gt; Commit -&gt; Pull -&gt; Push\n\nNow when you visit your web site, you’ll see the table of contents, and can navigate to the others file you linked.\n\n\n\n\nQuarto web pages are a great way to share work in progress with your colleagues. Here we showed an example with the materials we have created in this course. However, you can use these same steps to share the different files and progress of a project you’ve been working on. To do so simply requires thinking through your presentation so that it highlights the workflow to be reviewed. You can include multiple pages and build a simple web site and make your work accessible to people who aren’t set up to open your project in R. Your site could look something like this:"
  },
  {
    "objectID": "s01_r_git_install_guide.html",
    "href": "s01_r_git_install_guide.html",
    "title": "Installing R and Git on Your Computer",
    "section": "",
    "text": "To install R, visit cloud.r-project.org to download the most recent version for your operating system. The latest release is version 4.5.2 ([Not] Part in a Rumble, released 2025-10-31).\n\n\n\nWhile R is a programming language, RStudio is a software (often referred to as an IDE, Integrated Development Environment) that provides R programmers with a neat, easy-to-use interface for coding in R. There are a number of IDEs out there, but RStudio is arguably the best and definitely most popular among R programmers.\nNote: RStudio will not work without R installed, and you won’t particularly enjoy using R without having RStudio installed. Be sure to install both!\n\n\n\n\n\nImage Credit: Manny Gimond | Accessible at https://mgimond.github.io/ES218/R_vs_RStudio.html\n\n\n\n\n\nNew install: To install RStudio, visit https://posit.co/download/rstudio-desktop/. Download the free (“Open Source Edition”) Desktop version for your operating system. You should install the most up-to-date version available that is supported by your operating system.\nUpdate: If you already have RStudio and need to update: Open RStudio, and under ‘Help’ in the top menu, choose ‘Check for updates.’ If you have the most recent release, it will return ‘No update available. You are running the most recent version of RStudio.’ Otherwise, you should follow the instructions to install an updated version.\nOpen RStudio (logo you’ll click on shown below): If upon opening RStudio you are prompted to install Command Line Tools, do it.\n\n\n\n\n\n\n\n\n\n\n\nNote: on a Mac, you may need to install command line tools and XQuartz.\n\nTo install command line tools (if you’re not automatically prompted), run in the Terminal tab in RStudio: xcode-select --install\nVisit xquartz.org to download & install XQuartz\n\n\n\n\n\nQuarto is a scientific publishing tool built on Pandoc that allows R, Python, Julia, and ObservableJS users to create dynamic documents, websites, books and more.\nQuarto is now included with RStudio v2022.07.1+ so no need for a separate download/install if you have the latest version of RStudio! You can find all releases (current, pre, and older releases) on the Quarto website download page, should you want/need to reference them.\n\n\n\nYou should already have git on your device, but let’s check for it anyway.\n\nOpen RStudio\nIn the Terminal tab, run the following command:\n\n\nwhich git\n\nNOTE: on a Windows PC you might need to type where git instead…\n\nIf after running that you get something that looks like a file path to git on your computer, then you have git installed. For example, that might return something like this (or it could differ a bit): /usr/local/bin/git. If you instead get no response at all, you should download & install git from here: git-scm.com/downloads\n\nAn aside: Is it necessary to have Git installed in your machine for this workshop. GitHub’s Git Guides are a really wonderful resource to start learning about this topic.\n\n\n\n\nInstall the usethis and gitcreds packages in R by running the following in the RStudio Console:\n\n\ninstall.packages(“usethis”)\n\ninstall.packages(\"gitcreds\")\n\nA lot of scary looking red text will show up while this is installing - don’t panic. If you get to the end and see something like below (with no error) it’s installed successfully.\n\n\n\n\n\n\n\n\n\n\n\n\n\nIf you don’t already have a GitHub account, go to github.com and create one. Here are helpful considerations for choosing a username: happygitwithr.com/github-acct.html.\n\nOnce you’ve completed these steps you are ready for our workshop on Git and Github",
    "crumbs": [
      "Setup",
      "Installing R and Git on Your Computer"
    ]
  },
  {
    "objectID": "s01_r_git_install_guide.html#installation-steps",
    "href": "s01_r_git_install_guide.html#installation-steps",
    "title": "Installing R and Git on Your Computer",
    "section": "",
    "text": "To install R, visit cloud.r-project.org to download the most recent version for your operating system. The latest release is version 4.5.2 ([Not] Part in a Rumble, released 2025-10-31).\n\n\n\nWhile R is a programming language, RStudio is a software (often referred to as an IDE, Integrated Development Environment) that provides R programmers with a neat, easy-to-use interface for coding in R. There are a number of IDEs out there, but RStudio is arguably the best and definitely most popular among R programmers.\nNote: RStudio will not work without R installed, and you won’t particularly enjoy using R without having RStudio installed. Be sure to install both!\n\n\n\n\n\nImage Credit: Manny Gimond | Accessible at https://mgimond.github.io/ES218/R_vs_RStudio.html\n\n\n\n\n\nNew install: To install RStudio, visit https://posit.co/download/rstudio-desktop/. Download the free (“Open Source Edition”) Desktop version for your operating system. You should install the most up-to-date version available that is supported by your operating system.\nUpdate: If you already have RStudio and need to update: Open RStudio, and under ‘Help’ in the top menu, choose ‘Check for updates.’ If you have the most recent release, it will return ‘No update available. You are running the most recent version of RStudio.’ Otherwise, you should follow the instructions to install an updated version.\nOpen RStudio (logo you’ll click on shown below): If upon opening RStudio you are prompted to install Command Line Tools, do it.\n\n\n\n\n\n\n\n\n\n\n\nNote: on a Mac, you may need to install command line tools and XQuartz.\n\nTo install command line tools (if you’re not automatically prompted), run in the Terminal tab in RStudio: xcode-select --install\nVisit xquartz.org to download & install XQuartz\n\n\n\n\n\nQuarto is a scientific publishing tool built on Pandoc that allows R, Python, Julia, and ObservableJS users to create dynamic documents, websites, books and more.\nQuarto is now included with RStudio v2022.07.1+ so no need for a separate download/install if you have the latest version of RStudio! You can find all releases (current, pre, and older releases) on the Quarto website download page, should you want/need to reference them.\n\n\n\nYou should already have git on your device, but let’s check for it anyway.\n\nOpen RStudio\nIn the Terminal tab, run the following command:\n\n\nwhich git\n\nNOTE: on a Windows PC you might need to type where git instead…\n\nIf after running that you get something that looks like a file path to git on your computer, then you have git installed. For example, that might return something like this (or it could differ a bit): /usr/local/bin/git. If you instead get no response at all, you should download & install git from here: git-scm.com/downloads\n\nAn aside: Is it necessary to have Git installed in your machine for this workshop. GitHub’s Git Guides are a really wonderful resource to start learning about this topic.\n\n\n\n\nInstall the usethis and gitcreds packages in R by running the following in the RStudio Console:\n\n\ninstall.packages(“usethis”)\n\ninstall.packages(\"gitcreds\")\n\nA lot of scary looking red text will show up while this is installing - don’t panic. If you get to the end and see something like below (with no error) it’s installed successfully.\n\n\n\n\n\n\n\n\n\n\n\n\n\nIf you don’t already have a GitHub account, go to github.com and create one. Here are helpful considerations for choosing a username: happygitwithr.com/github-acct.html.\n\nOnce you’ve completed these steps you are ready for our workshop on Git and Github",
    "crumbs": [
      "Setup",
      "Installing R and Git on Your Computer"
    ]
  },
  {
    "objectID": "s01_r_git_install_guide.html#troubleshooting",
    "href": "s01_r_git_install_guide.html#troubleshooting",
    "title": "Installing R and Git on Your Computer",
    "section": "2 Troubleshooting",
    "text": "2 Troubleshooting\n\n\n\n\n\n\nWarningIssues installing Git on a Windows\n\n\n\nIf you download Git and the Git commands still not recognized by your computer, check your computer’s PATHS.\nTo do this, follow the instructions in this link on how to set the right PATHS.\nRestart your computer and try running git --version on the terminal. You should get something like git version XX.XX (but with numbers instead of Xs).\nIf you see the git version printed out in your terminal, you are all set",
    "crumbs": [
      "Setup",
      "Installing R and Git on Your Computer"
    ]
  },
  {
    "objectID": "index.html#nceas-expertise",
    "href": "index.html#nceas-expertise",
    "title": "About the course",
    "section": "1 NCEAS Expertise",
    "text": "1 NCEAS Expertise\nThe National Center for Ecological Analysis and Synthesis (NCEAS), a research affiliate of UCSB, is a leading expert on interdisciplinary data science and works collaboratively to answer the world’s largest and most complex questions. The NCEAS approach leverages existing data and employs a team science philosophy to squeeze out all potential insights and solutions efficiently - this is called synthesis science.\nNCEAS has 30 years of success with this model among working groups and environmental professionals. Together with the USGS Climate Adaptation Postdoctoral Fellows Program we are excited to pass along skills, workflows, mindsets learn throughout the years.\n\n\n\n\n\n\nTipLearning Objectives\n\n\n\n\nImplement reproducible scientific workflows throughout all aspects of a project\nEstablish best practices and utilize tools like Git & GitHub to optimize your collaboration\nEffectively manage data using tidy data practices\nBetter communicate scientific analyses and results using Markdown, GitHub webpages, and R packages like ggplot2 and Shiny\nIncrease your familiarity and confidence with data science tools",
    "crumbs": [
      "About the course"
    ]
  },
  {
    "objectID": "index.html#code-of-conduct",
    "href": "index.html#code-of-conduct",
    "title": "About the course",
    "section": "2 Code of Conduct",
    "text": "2 Code of Conduct\nBy participating in this activity you agree to abide by the NCEAS Code of Conduct.",
    "crumbs": [
      "About the course"
    ]
  },
  {
    "objectID": "index.html#about-this-book",
    "href": "index.html#about-this-book",
    "title": "About the course",
    "section": "3 About this book",
    "text": "3 About this book\nThese written materials are the result of a continuous and collaborative effort at NCEAS to help researchers make their work more transparent and reproducible. This work began in the early 2000’s, and reflects the expertise and diligence of many, many individuals. The primary authors are listed in the citation below, with additional contributors recognized for their role in developing previous iterations of these or similar materials.\nThis work is licensed under a Creative Commons Attribution 4.0 International License.\nCitation: Casey O’Hara (2025), NCEAS Workshop for USGS CAP Fellows, December 2025, NCEAS Learning Hub. URL https://nceas-learning-hub.github.io/cap_fellows_workshop.\nAdditional contributors: Ben Bolker, Amber E. Budden, Julien Brun, Samantha Csik, Halina Do-Linh, Natasha Haycock-Chavez, S. Jeanette Clark, Julie Lowndes, Stephanie Hampton, Matt Jones, Samantha Katz, Erin McLean, Bryce Mecum, Deanna Pennington, Karthik Ram, Jim Regetz, Tracy Teal, Camila Vargas Poulsen, Daphne Virlar-Knight, Leah Wasser.\nThis is a Quarto website. To learn more about Quarto websites visit https://quarto.org/docs/websites.",
    "crumbs": [
      "About the course"
    ]
  },
  {
    "objectID": "s05_github_project_management.html",
    "href": "s05_github_project_management.html",
    "title": "GitHub for Project Management",
    "section": "",
    "text": "TipLearning Objectives\n\n\n\n\nUtilize GitHub’s project management tools to organize and manage projects\nPractice creating issues in GitHub\nCraft informative READMEs for Git repositories",
    "crumbs": [
      "Git/GitHub",
      "GitHub for Project Management"
    ]
  },
  {
    "objectID": "s05_github_project_management.html#slides",
    "href": "s05_github_project_management.html#slides",
    "title": "GitHub for Project Management",
    "section": "Slides",
    "text": "Slides",
    "crumbs": [
      "Git/GitHub",
      "GitHub for Project Management"
    ]
  },
  {
    "objectID": "s05_github_project_management.html#exercise-github-issues",
    "href": "s05_github_project_management.html#exercise-github-issues",
    "title": "GitHub for Project Management",
    "section": "1 Exercise: GitHub Issues",
    "text": "1 Exercise: GitHub Issues\nGet back together with your partner that you collaborate for the Lobster Report.\n\n\n\n\n\n\nExerciseExercise 1 - Step 1\n\n\n\n\n\n\nOwner creates a new Issue and tags collaborator.\n\n\n\n\n\n\nSteps\n\n\nNavigate to the Lobster Report repository\nGo to the “Issue” tab of the repository\nClick on “New Issue”\nGive the Issue a title (Eg: Choose which plot to include in final report)\nDescribe the issue and tag your collaborator by adding @ followed by their username (Practice Markdown syntax when writing the issue)\nClick on Submit New Issue\n\n\n\n\n\n\n\n\nExerciseExercise 2 - Step 2\n\n\n\n\n\n\nCollaborator responds to Issue and creates a checklist\n\n\n\n\n\n\nSteps\n\n\nCollaborator navigates to issue (either from the email notification or going into the Issue tab in the Lobster Report repo)\nRespond Issue and include a To Do list indicating next steps (tip: Markdown syntax for list is /- [ ])\nSubmit your response\n\n\n\n\n\n\n\n\nExerciseExercise 3 - Step 3\n\n\n\n\n\n\nCollaborator create a GitHub Issues referencing code on one of the .qmd files\n\n\n\n\n\n\nSteps\n\n\nNavigate to a script in the Lobster Report Report repository\nHover over the line you want to reference in the Issue\nClick on the line number (on the left), then click on the three dots right next to the number\nChoose the option “Reference in new issue”\nWrite a description of the “issue” you want to address\nSubmit Issue\nAssign Issue to Owner\n\n\n\n\n\n\n\n\nExerciseExercise 4 - Step 4\n\n\n\n\n\n\nOwner reacts to issue with an emoji and adds a label\n\n\n\n\n\n\nSteps\n\n\nOwner navigates to issue (either from the email notification or going into the Issue tab in the Lobster Report repo)\nAdd an emoji to issue submitted by Collaborator\nAdd a label\n\nOn the right side menu click on Label\nEither choose one of the default labels or create your own by selecting “Edit labels”",
    "crumbs": [
      "Git/GitHub",
      "GitHub for Project Management"
    ]
  },
  {
    "objectID": "s05_github_project_management.html#exercise-practice-creating-informative-readmes",
    "href": "s05_github_project_management.html#exercise-practice-creating-informative-readmes",
    "title": "GitHub for Project Management",
    "section": "2 Exercise: Practice creating informative READMEs",
    "text": "2 Exercise: Practice creating informative READMEs\nYou can do this either for the training_&lt;username&gt; repo, or the Lobster Report repo (make sure just one of you edits this one) or edit a personal repo from one of your projects. Make sure to include the 6 core elements:\n\nA short, but descriptive title\nA brief explanation of the repository’s purpose\nA concise description of what’s housed in the repository\nDetails regarding data access\nA list of authors or contributors (for collaborative work)\nReferences / acknowledgements\n\n\n\n\n\n\n\nNoteREADME Examples\n\n\n\n\nA shiny dashboard for exploring my personal Strava data, by Sam Csik\nThomas Fire Data Analysis by Anna Ramji\nArt of README by Kira Oakley",
    "crumbs": [
      "Git/GitHub",
      "GitHub for Project Management"
    ]
  },
  {
    "objectID": "slides/github_introduction/slides1_motivating_example.html#title-slide",
    "href": "slides/github_introduction/slides1_motivating_example.html#title-slide",
    "title": "CAP Fellows workshop resources",
    "section": "",
    "text": "Git & GitHub\nA motivating example"
  }
]